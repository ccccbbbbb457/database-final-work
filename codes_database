/*
 Navicat Premium Dump SQL

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 80043 (8.0.43)
 Source Host           : localhost:3306
 Source Schema         : hospitalsystem

 Target Server Type    : MySQL
 Target Server Version : 80043 (8.0.43)
 File Encoding         : 65001

 Date: 28/12/2025 23:10:41
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for appointment
-- ----------------------------
DROP TABLE IF EXISTS `appointment`;
CREATE TABLE `appointment`  (
  `appointment_id` int NOT NULL AUTO_INCREMENT,
  `patient_id` int NOT NULL,
  `dept_id` int NOT NULL,
  `doctor_id` int NULL DEFAULT NULL,
  `expected_time` datetime NOT NULL,
  `appointment_status` enum('待就诊','已取消','已完成') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '待就诊',
  `cancel_time` timestamp NULL DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`appointment_id`) USING BTREE,
  INDEX `dept_id`(`dept_id` ASC) USING BTREE,
  INDEX `doctor_id`(`doctor_id` ASC) USING BTREE,
  INDEX `idx_appt_patient`(`patient_id` ASC) USING BTREE COMMENT '预约患者ID普通索引',
  INDEX `idx_appt_time`(`expected_time` ASC) USING BTREE COMMENT '预约时间普通索引',
  INDEX `idx_appt_status`(`appointment_status` ASC) USING BTREE COMMENT '预约状态普通索引',
  CONSTRAINT `appointment_ibfk_1` FOREIGN KEY (`patient_id`) REFERENCES `patient` (`patient_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `appointment_ibfk_2` FOREIGN KEY (`dept_id`) REFERENCES `department` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `appointment_ibfk_3` FOREIGN KEY (`doctor_id`) REFERENCES `doctor` (`doctor_id`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of appointment
-- ----------------------------

-- ----------------------------
-- Table structure for clinicroom
-- ----------------------------
DROP TABLE IF EXISTS `clinicroom`;
CREATE TABLE `clinicroom`  (
  `room_id` int NOT NULL AUTO_INCREMENT,
  `room_number` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `dept_id` int NOT NULL,
  `is_available` tinyint(1) NULL DEFAULT 1,
  `room_type` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`room_id`) USING BTREE,
  UNIQUE INDEX `room_number`(`room_number` ASC) USING BTREE,
  UNIQUE INDEX `uk_room_number`(`room_number` ASC) USING BTREE COMMENT '诊室编号唯一索引',
  INDEX `idx_room_dept`(`dept_id` ASC) USING BTREE COMMENT '诊室所属科室ID普通索引',
  CONSTRAINT `clinicroom_ibfk_1` FOREIGN KEY (`dept_id`) REFERENCES `department` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of clinicroom
-- ----------------------------

-- ----------------------------
-- Table structure for department
-- ----------------------------
DROP TABLE IF EXISTS `department`;
CREATE TABLE `department`  (
  `dept_id` int NOT NULL AUTO_INCREMENT,
  `dept_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `dept_location` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `dept_phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`dept_id`) USING BTREE,
  UNIQUE INDEX `dept_name`(`dept_name` ASC) USING BTREE,
  UNIQUE INDEX `uk_dept_name`(`dept_name` ASC) USING BTREE COMMENT '科室名称唯一索引',
  INDEX `idx_dept_name`(`dept_name` ASC) USING BTREE COMMENT '科室名称普通索引，提升查询效率'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of department
-- ----------------------------

-- ----------------------------
-- Table structure for doctor
-- ----------------------------
DROP TABLE IF EXISTS `doctor`;
CREATE TABLE `doctor`  (
  `doctor_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `dept_id` int NOT NULL,
  `is_available` tinyint(1) NULL DEFAULT 1,
  `phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`doctor_id`) USING BTREE,
  INDEX `idx_doctor_name`(`name` ASC) USING BTREE COMMENT '医生姓名普通索引',
  INDEX `idx_doctor_dept`(`dept_id` ASC) USING BTREE COMMENT '医生所属科室ID普通索引（外键关联，提升联查效率）',
  CONSTRAINT `doctor_ibfk_1` FOREIGN KEY (`dept_id`) REFERENCES `department` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of doctor
-- ----------------------------

-- ----------------------------
-- Table structure for medicine
-- ----------------------------
DROP TABLE IF EXISTS `medicine`;
CREATE TABLE `medicine`  (
  `medicine_id` int NOT NULL AUTO_INCREMENT,
  `medicine_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `specification` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `unit` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `price` decimal(10, 2) NOT NULL,
  `stock` int NOT NULL DEFAULT 0,
  `manufacturer` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `expiry_date` date NULL DEFAULT NULL,
  `is_available` tinyint(1) NULL DEFAULT 1,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`medicine_id`) USING BTREE,
  INDEX `idx_medicine_name`(`medicine_name` ASC) USING BTREE COMMENT '药品名称普通索引',
  INDEX `idx_medicine_stock`(`is_available` ASC, `stock` ASC) USING BTREE COMMENT '药品可用状态+库存联合普通索引'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of medicine
-- ----------------------------

-- ----------------------------
-- Table structure for operationlog
-- ----------------------------
DROP TABLE IF EXISTS `operationlog`;
CREATE TABLE `operationlog`  (
  `log_id` int NOT NULL AUTO_INCREMENT,
  `operator` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `operation_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `related_id` int NOT NULL,
  `operation_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `operation_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `operation_status` enum('成功','失败') CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '成功',
  PRIMARY KEY (`log_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of operationlog
-- ----------------------------

-- ----------------------------
-- Table structure for patient
-- ----------------------------
DROP TABLE IF EXISTS `patient`;
CREATE TABLE `patient`  (
  `patient_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `id_card` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `gender` enum('男','女') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `age` int NULL DEFAULT NULL,
  `address` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`patient_id`) USING BTREE,
  UNIQUE INDEX `id_card`(`id_card` ASC) USING BTREE,
  UNIQUE INDEX `uk_patient_idcard`(`id_card` ASC) USING BTREE COMMENT '患者身份证号唯一索引',
  INDEX `idx_patient_phone`(`phone` ASC) USING BTREE COMMENT '患者手机号普通索引',
  INDEX `idx_patient_name`(`name` ASC) USING BTREE COMMENT '患者姓名普通索引'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of patient
-- ----------------------------

-- ----------------------------
-- Table structure for payment
-- ----------------------------
DROP TABLE IF EXISTS `payment`;
CREATE TABLE `payment`  (
  `payment_id` int NOT NULL AUTO_INCREMENT,
  `visit_id` int NOT NULL,
  `prescription_id` int NULL DEFAULT NULL,
  `total_amount` decimal(10, 2) NOT NULL DEFAULT 0.00,
  `insurance_amount` decimal(10, 2) NULL DEFAULT 0.00,
  `self_pay_amount` decimal(10, 2) NOT NULL DEFAULT 0.00,
  `payment_method` enum('现金','微信','支付宝','医保') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '现金',
  `payment_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `payer_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`payment_id`) USING BTREE,
  INDEX `prescription_id`(`prescription_id` ASC) USING BTREE,
  INDEX `idx_payment_visit`(`visit_id` ASC) USING BTREE COMMENT '收费记录关联就诊ID普通索引',
  INDEX `idx_payment_time`(`payment_time` ASC) USING BTREE COMMENT '缴费时间普通索引',
  INDEX `idx_payment_method`(`payment_method` ASC) USING BTREE COMMENT '支付方式普通索引',
  CONSTRAINT `payment_ibfk_1` FOREIGN KEY (`visit_id`) REFERENCES `visitrecord` (`visit_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `payment_ibfk_2` FOREIGN KEY (`prescription_id`) REFERENCES `prescription` (`prescription_id`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of payment
-- ----------------------------

-- ----------------------------
-- Table structure for prescription
-- ----------------------------
DROP TABLE IF EXISTS `prescription`;
CREATE TABLE `prescription`  (
  `prescription_id` int NOT NULL AUTO_INCREMENT,
  `visit_id` int NOT NULL,
  `doctor_id` int NOT NULL,
  `prescribe_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `prescription_status` enum('未取药','已取药','已作废') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '未取药',
  PRIMARY KEY (`prescription_id`) USING BTREE,
  INDEX `doctor_id`(`doctor_id` ASC) USING BTREE,
  INDEX `idx_prescription_visit`(`visit_id` ASC) USING BTREE COMMENT '处方关联就诊记录ID普通索引',
  INDEX `idx_prescription_status`(`prescription_status` ASC) USING BTREE COMMENT '处方状态普通索引',
  CONSTRAINT `prescription_ibfk_1` FOREIGN KEY (`visit_id`) REFERENCES `visitrecord` (`visit_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `prescription_ibfk_2` FOREIGN KEY (`doctor_id`) REFERENCES `doctor` (`doctor_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of prescription
-- ----------------------------

-- ----------------------------
-- Table structure for prescriptionmedicine
-- ----------------------------
DROP TABLE IF EXISTS `prescriptionmedicine`;
CREATE TABLE `prescriptionmedicine`  (
  `pm_id` int NOT NULL AUTO_INCREMENT,
  `prescription_id` int NOT NULL,
  `medicine_id` int NOT NULL,
  `quantity` int NOT NULL DEFAULT 1,
  `usage_desc` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`pm_id`) USING BTREE,
  UNIQUE INDEX `uk_prescription_medicine`(`prescription_id` ASC, `medicine_id` ASC) USING BTREE,
  INDEX `idx_pm_prescription`(`prescription_id` ASC) USING BTREE COMMENT '处方药品关联-处方ID普通索引',
  INDEX `idx_pm_medicine`(`medicine_id` ASC) USING BTREE COMMENT '处方药品关联-药品ID普通索引',
  CONSTRAINT `prescriptionmedicine_ibfk_1` FOREIGN KEY (`prescription_id`) REFERENCES `prescription` (`prescription_id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `prescriptionmedicine_ibfk_2` FOREIGN KEY (`medicine_id`) REFERENCES `medicine` (`medicine_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of prescriptionmedicine
-- ----------------------------

-- ----------------------------
-- Table structure for schedule
-- ----------------------------
DROP TABLE IF EXISTS `schedule`;
CREATE TABLE `schedule`  (
  `schedule_id` int NOT NULL AUTO_INCREMENT,
  `doctor_id` int NOT NULL,
  `room_id` int NOT NULL,
  `work_date` date NOT NULL,
  `start_time` time NOT NULL,
  `end_time` time NOT NULL,
  `schedule_status` enum('正常','调休','请假') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '正常',
  PRIMARY KEY (`schedule_id`) USING BTREE,
  INDEX `room_id`(`room_id` ASC) USING BTREE,
  INDEX `idx_schedule_doctor`(`doctor_id` ASC) USING BTREE COMMENT '排班医生ID普通索引',
  INDEX `idx_schedule_date`(`work_date` ASC) USING BTREE COMMENT '排班日期普通索引',
  CONSTRAINT `schedule_ibfk_1` FOREIGN KEY (`doctor_id`) REFERENCES `doctor` (`doctor_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `schedule_ibfk_2` FOREIGN KEY (`room_id`) REFERENCES `clinicroom` (`room_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of schedule
-- ----------------------------

-- ----------------------------
-- Table structure for staff
-- ----------------------------
DROP TABLE IF EXISTS `staff`;
CREATE TABLE `staff`  (
  `staff_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `role` enum('前台','医生','管理员','护士','药房管理员','收费员') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '前台',
  `dept_id` int NOT NULL,
  `phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `is_active` tinyint(1) NULL DEFAULT 1,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`staff_id`) USING BTREE,
  UNIQUE INDEX `username`(`username` ASC) USING BTREE,
  UNIQUE INDEX `uk_staff_username`(`username` ASC) USING BTREE COMMENT '员工登录账号唯一索引',
  INDEX `idx_staff_name`(`name` ASC) USING BTREE COMMENT '员工姓名普通索引',
  INDEX `idx_staff_role`(`role` ASC) USING BTREE COMMENT '员工角色普通索引',
  INDEX `idx_staff_dept`(`dept_id` ASC) USING BTREE COMMENT '员工所属科室ID普通索引',
  CONSTRAINT `staff_ibfk_1` FOREIGN KEY (`dept_id`) REFERENCES `department` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of staff
-- ----------------------------

-- ----------------------------
-- Table structure for visitrecord
-- ----------------------------
DROP TABLE IF EXISTS `visitrecord`;
CREATE TABLE `visitrecord`  (
  `visit_id` int NOT NULL AUTO_INCREMENT,
  `patient_id` int NOT NULL,
  `doctor_id` int NOT NULL,
  `room_id` int NOT NULL,
  `appointment_id` int NULL DEFAULT NULL,
  `visit_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `symptoms` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL,
  `diagnosis` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL,
  `visit_status` enum('就诊中','已缴费','已离院') CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '就诊中',
  PRIMARY KEY (`visit_id`) USING BTREE,
  INDEX `doctor_id`(`doctor_id` ASC) USING BTREE,
  INDEX `room_id`(`room_id` ASC) USING BTREE,
  INDEX `appointment_id`(`appointment_id` ASC) USING BTREE,
  INDEX `idx_visit_patient`(`patient_id` ASC) USING BTREE COMMENT '就诊患者ID普通索引',
  INDEX `idx_visit_time`(`visit_time` ASC) USING BTREE COMMENT '就诊时间普通索引',
  INDEX `idx_visit_status`(`visit_status` ASC) USING BTREE COMMENT '就诊状态普通索引',
  CONSTRAINT `visitrecord_ibfk_1` FOREIGN KEY (`patient_id`) REFERENCES `patient` (`patient_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `visitrecord_ibfk_2` FOREIGN KEY (`doctor_id`) REFERENCES `doctor` (`doctor_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `visitrecord_ibfk_3` FOREIGN KEY (`room_id`) REFERENCES `clinicroom` (`room_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `visitrecord_ibfk_4` FOREIGN KEY (`appointment_id`) REFERENCES `appointment` (`appointment_id`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of visitrecord
-- ----------------------------

-- ----------------------------
-- View structure for v_appointment_info
-- ----------------------------
DROP VIEW IF EXISTS `v_appointment_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_appointment_info` AS select `a`.`appointment_id` AS `appointment_id`,`p`.`patient_id` AS `patient_id`,`p`.`name` AS `patient_name`,`de`.`dept_id` AS `department_id`,`de`.`dept_name` AS `department_name`,`d`.`doctor_id` AS `doctor_id`,`d`.`name` AS `doctor_name`,`a`.`expected_time` AS `expected_datetime`,`a`.`appointment_status` AS `appointment_status`,`a`.`create_time` AS `create_datetime`,`a`.`cancel_time` AS `cancel_datetime` from (((`appointment` `a` left join `patient` `p` on((`a`.`patient_id` = `p`.`patient_id`))) left join `department` `de` on((`a`.`dept_id` = `de`.`dept_id`))) left join `doctor` `d` on((`a`.`doctor_id` = `d`.`doctor_id`)));

-- ----------------------------
-- View structure for v_doctor_info
-- ----------------------------
DROP VIEW IF EXISTS `v_doctor_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_doctor_info` AS select `d`.`doctor_id` AS `doctor_id`,`d`.`name` AS `doctor_name`,`d`.`title` AS `job_title`,`d`.`phone` AS `phone_number`,`d`.`is_available` AS `is_available`,`de`.`dept_id` AS `department_id`,`de`.`dept_name` AS `department_name`,`de`.`dept_location` AS `department_location` from (`doctor` `d` left join `department` `de` on((`d`.`dept_id` = `de`.`dept_id`)));

-- ----------------------------
-- View structure for v_medicine_stock
-- ----------------------------
DROP VIEW IF EXISTS `v_medicine_stock`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_medicine_stock` AS select `medicine`.`medicine_id` AS `medicine_id`,`medicine`.`medicine_name` AS `medicine_name`,`medicine`.`specification` AS `medicine_spec`,`medicine`.`unit` AS `medicine_unit`,`medicine`.`price` AS `medicine_unit_price`,`medicine`.`stock` AS `stock_quantity`,`medicine`.`manufacturer` AS `manufacturer`,`medicine`.`expiry_date` AS `expiry_date`,`medicine`.`is_available` AS `is_available` from `medicine` where (`medicine`.`is_available` = true);

-- ----------------------------
-- View structure for v_patient_info
-- ----------------------------
DROP VIEW IF EXISTS `v_patient_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_patient_info` AS select `patient`.`patient_id` AS `patient_id`,`patient`.`name` AS `patient_name`,`patient`.`gender` AS `gender`,`patient`.`age` AS `age`,`patient`.`phone` AS `phone_number`,`patient`.`id_card` AS `id_card_number`,`patient`.`address` AS `residential_address`,`patient`.`create_time` AS `create_datetime` from `patient`;

-- ----------------------------
-- View structure for v_payment_info
-- ----------------------------
DROP VIEW IF EXISTS `v_payment_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_payment_info` AS select `py`.`payment_id` AS `payment_id`,`vr`.`visit_id` AS `visit_id`,`p`.`patient_id` AS `patient_id`,`p`.`name` AS `patient_name`,`pr`.`prescription_id` AS `prescription_id`,`py`.`total_amount` AS `total_amount`,`py`.`insurance_amount` AS `insurance_reimbursement`,`py`.`self_pay_amount` AS `personal_self_pay`,`py`.`payment_method` AS `payment_method`,`py`.`payer_name` AS `payer_name`,`py`.`payment_time` AS `payment_datetime` from (((`payment` `py` left join `visitrecord` `vr` on((`py`.`visit_id` = `vr`.`visit_id`))) left join `patient` `p` on((`vr`.`patient_id` = `p`.`patient_id`))) left join `prescription` `pr` on((`py`.`prescription_id` = `pr`.`prescription_id`)));

-- ----------------------------
-- View structure for v_prescription_medicine_info
-- ----------------------------
DROP VIEW IF EXISTS `v_prescription_medicine_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_prescription_medicine_info` AS select `pm`.`pm_id` AS `prescription_medicine_id`,`pr`.`prescription_id` AS `prescription_id`,`pr`.`visit_id` AS `visit_id`,`d`.`doctor_id` AS `doctor_id`,`d`.`name` AS `doctor_name`,`m`.`medicine_id` AS `medicine_id`,`m`.`medicine_name` AS `medicine_name`,`m`.`specification` AS `medicine_spec`,`m`.`unit` AS `medicine_unit`,`m`.`price` AS `medicine_unit_price`,`pm`.`quantity` AS `medicine_quantity`,(`m`.`price` * `pm`.`quantity`) AS `medicine_subtotal`,`pm`.`usage_desc` AS `usage_instructions`,`pr`.`prescribe_time` AS `prescribe_datetime`,`pr`.`prescription_status` AS `prescription_status` from (((`prescriptionmedicine` `pm` left join `prescription` `pr` on((`pm`.`prescription_id` = `pr`.`prescription_id`))) left join `doctor` `d` on((`pr`.`doctor_id` = `d`.`doctor_id`))) left join `medicine` `m` on((`pm`.`medicine_id` = `m`.`medicine_id`)));

-- ----------------------------
-- View structure for v_schedule_info
-- ----------------------------
DROP VIEW IF EXISTS `v_schedule_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_schedule_info` AS select `s`.`schedule_id` AS `schedule_id`,`d`.`doctor_id` AS `doctor_id`,`d`.`name` AS `doctor_name`,`de`.`dept_id` AS `department_id`,`de`.`dept_name` AS `department_name`,`cr`.`room_id` AS `clinic_room_id`,`cr`.`room_number` AS `clinic_room_number`,`s`.`work_date` AS `work_date`,`s`.`start_time` AS `work_start_time`,`s`.`end_time` AS `work_end_time`,`s`.`schedule_status` AS `schedule_status` from (((`schedule` `s` left join `doctor` `d` on((`s`.`doctor_id` = `d`.`doctor_id`))) left join `clinicroom` `cr` on((`s`.`room_id` = `cr`.`room_id`))) left join `department` `de` on((`d`.`dept_id` = `de`.`dept_id`)));

-- ----------------------------
-- View structure for v_visit_record_info
-- ----------------------------
DROP VIEW IF EXISTS `v_visit_record_info`;
CREATE ALGORITHM = UNDEFINED SQL SECURITY DEFINER VIEW `v_visit_record_info` AS select `vr`.`visit_id` AS `visit_id`,`p`.`patient_id` AS `patient_id`,`p`.`name` AS `patient_name`,`d`.`doctor_id` AS `doctor_id`,`d`.`name` AS `doctor_name`,`cr`.`room_id` AS `clinic_room_id`,`cr`.`room_number` AS `clinic_room_number`,`a`.`appointment_id` AS `appointment_id`,`vr`.`visit_time` AS `visit_datetime`,`vr`.`symptoms` AS `patient_symptoms`,`vr`.`diagnosis` AS `diagnosis_result`,`vr`.`visit_status` AS `visit_status` from ((((`visitrecord` `vr` left join `patient` `p` on((`vr`.`patient_id` = `p`.`patient_id`))) left join `doctor` `d` on((`vr`.`doctor_id` = `d`.`doctor_id`))) left join `clinicroom` `cr` on((`vr`.`room_id` = `cr`.`room_id`))) left join `appointment` `a` on((`vr`.`appointment_id` = `a`.`appointment_id`)));

-- ----------------------------
-- Function structure for fn_calc_patient_total_payment
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_calc_patient_total_payment`;
delimiter ;;
CREATE FUNCTION `fn_calc_patient_total_payment`(p_patient_id INT)
 RETURNS decimal(10,2)
  DETERMINISTIC
BEGIN
    DECLARE total_payment DECIMAL(10,2) DEFAULT 0.00; -- 声明总缴费金额变量，默认0

    -- 计算患者总缴费金额（对应英文视图v_payment_info）
    SELECT SUM(total_amount) INTO total_payment
    FROM v_payment_info
    WHERE patient_id = p_patient_id;

    -- 处理NULL值（无缴费记录时返回0.00）
    IF total_payment IS NULL THEN
        SET total_payment = 0.00;
    END IF;

    RETURN total_payment;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_calc_prescription_total
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_calc_prescription_total`;
delimiter ;;
CREATE FUNCTION `fn_calc_prescription_total`(p_prescription_id INT)
 RETURNS decimal(10,2)
  DETERMINISTIC
BEGIN
    DECLARE total_amount DECIMAL(10,2) DEFAULT 0.00; -- 声明总金额变量，默认0

    -- 计算处方总金额（对应英文视图v_prescription_medicine_info）
    SELECT SUM(medicine_subtotal) INTO total_amount
    FROM v_prescription_medicine_info
    WHERE prescription_id = p_prescription_id;

    -- 处理NULL值（无药品时返回0.00）
    IF total_amount IS NULL THEN
        SET total_amount = 0.00;
    END IF;

    RETURN total_amount;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_get_doctor_dept
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_get_doctor_dept`;
delimiter ;;
CREATE FUNCTION `fn_get_doctor_dept`(p_doctor_id INT)
 RETURNS varchar(50) CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci
  DETERMINISTIC
BEGIN
    DECLARE dept_name VARCHAR(50); -- 声明返回值变量

    -- 查询科室名称（对应英文视图v_doctor_info）
    SELECT department_name INTO dept_name
    FROM v_doctor_info
    WHERE doctor_id = p_doctor_id
    LIMIT 1;

    RETURN dept_name;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_get_medicine_stock
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_get_medicine_stock`;
delimiter ;;
CREATE FUNCTION `fn_get_medicine_stock`(p_medicine_id INT)
 RETURNS int
  DETERMINISTIC
BEGIN
    DECLARE stock_num INT DEFAULT 0; -- 声明库存变量，默认0

    -- 查询药品库存（对应英文视图v_medicine_stock）
    SELECT stock_quantity INTO stock_num
    FROM v_medicine_stock
    WHERE medicine_id = p_medicine_id
    LIMIT 1;

    -- 处理NULL值（无该药品时返回0）
    IF stock_num IS NULL THEN
        SET stock_num = 0;
    END IF;

    RETURN stock_num;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_get_patient_name
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_get_patient_name`;
delimiter ;;
CREATE FUNCTION `fn_get_patient_name`(p_patient_id INT)
 RETURNS varchar(50) CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci
  DETERMINISTIC
BEGIN
    DECLARE patient_name VARCHAR(50); -- 声明返回值变量

    -- 查询患者姓名（对应英文视图v_patient_info）
    SELECT patient_name INTO patient_name
    FROM v_patient_info
    WHERE patient_id = p_patient_id
    LIMIT 1; -- 限制单条结果，避免多值报错

    RETURN patient_name;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_get_visit_doctor
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_get_visit_doctor`;
delimiter ;;
CREATE FUNCTION `fn_get_visit_doctor`(p_visit_id INT)
 RETURNS varchar(50) CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci
  DETERMINISTIC
BEGIN
    DECLARE doctor_name VARCHAR(50); -- 声明医生姓名变量

    -- 查询接诊医生姓名（对应英文视图v_visit_record_info）
    SELECT doctor_name INTO doctor_name
    FROM v_visit_record_info
    WHERE visit_id = p_visit_id
    LIMIT 1;

    RETURN doctor_name;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_has_unfinished_appointment
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_has_unfinished_appointment`;
delimiter ;;
CREATE FUNCTION `fn_has_unfinished_appointment`(p_patient_id INT)
 RETURNS tinyint(1)
  DETERMINISTIC
BEGIN
    DECLARE has_unfinished TINYINT(1) DEFAULT 0; -- 声明标记变量，默认0（无）
    DECLARE appointment_count INT DEFAULT 0; -- 声明预约数量变量

    -- 查询患者“待就诊”状态的预约数量
    SELECT COUNT(*) INTO appointment_count
    FROM v_appointment_info
    WHERE patient_id = p_patient_id
      AND appointment_status = '待就诊'; -- 匹配你的预约状态枚举值

    -- 若数量大于0，标记为1（有未完成预约）
    IF appointment_count > 0 THEN
        SET has_unfinished = 1;
    END IF;

    RETURN has_unfinished;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for fn_is_medicine_stock_low
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_is_medicine_stock_low`;
delimiter ;;
CREATE FUNCTION `fn_is_medicine_stock_low`(p_medicine_id INT, -- 输入参数：药品ID
    p_min_stock INT)
 RETURNS tinyint(1)
  DETERMINISTIC
BEGIN
    DECLARE is_low TINYINT(1) DEFAULT 0; -- 声明标记变量，默认0（库存充足）
    DECLARE current_stock INT DEFAULT 0; -- 声明当前库存变量

    -- 获取药品当前库存
    SET current_stock = fn_get_medicine_stock(p_medicine_id); -- 调用已创建的存储函数

    -- 若当前库存低于阈值，标记为1（库存不足）
    IF current_stock < p_min_stock THEN
        SET is_low = 1;
    END IF;

    RETURN is_low;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_batch_update_doctor_available
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_batch_update_doctor_available`;
delimiter ;;
CREATE PROCEDURE `proc_batch_update_doctor_available`(IN p_doctor_ids VARCHAR(1000), -- 医生ID列表，逗号分隔（如：1,2,3）
    IN p_is_available BOOLEAN)
BEGIN
    -- 批量更新医生状态（对应Doctor表，无语法错误）
    UPDATE Doctor
    SET is_available = p_is_available
    WHERE FIND_IN_SET(doctor_id, p_doctor_ids) > 0;

    -- 返回更新结果提示
    SELECT 
        CONCAT('成功更新 ', ROW_COUNT(), ' 位医生的出诊状态') AS 操作结果,
        IF(ROW_COUNT() > 0, '更新成功', '无匹配医生ID，更新失败') AS 状态说明;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_create_prescription_with_stock
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_create_prescription_with_stock`;
delimiter ;;
CREATE PROCEDURE `proc_create_prescription_with_stock`(IN p_visit_id INT,          -- 就诊ID
    IN p_doctor_id INT,         -- 开处方医生ID
    IN p_medicine_id INT,       -- 药品ID
    IN p_quantity INT,          -- 药品数量
    IN p_usage_desc VARCHAR(200), -- 用法用量
    OUT p_result VARCHAR(100))
proc_label: BEGIN -- 定义存储过程标签，用于LEAVE退出
    DECLARE v_stock INT DEFAULT 0; -- 存储药品当前库存
    DECLARE v_prescription_id INT; -- 存储新建处方ID

    -- 声明异常处理：错误则回滚
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = '开立处方失败：系统异常，数据已回滚';
    END;

    -- 步骤0：先查询药品库存，判断是否充足
    SELECT stock INTO v_stock
    FROM Medicine
    WHERE medicine_id = p_medicine_id AND is_available = TRUE;

    -- 库存不足时，设置提示并退出存储过程（用LEAVE替代RETURN，兼容低版本）
    IF v_stock < p_quantity THEN
        SET p_result = CONCAT('开立处方失败：药品库存不足（当前库存：', v_stock, '，需扣减：', p_quantity, '）');
        LEAVE proc_label; -- 退出存储过程，不执行后续操作（替代RETURN）
    END IF;

    -- 启动事务
    START TRANSACTION;

    -- 步骤1：创建处方主记录（核心操作1）
    INSERT INTO Prescription (
        visit_id, doctor_id, prescribe_time, prescription_status
    )
    VALUES (
        p_visit_id, p_doctor_id, NOW(), '未取药'
    );
    SET v_prescription_id = LAST_INSERT_ID(); -- 获取新建处方ID

    -- 步骤2：创建处方药品明细（核心操作2）
    INSERT INTO PrescriptionMedicine (
        prescription_id, medicine_id, quantity, usage_desc
    )
    VALUES (
        v_prescription_id, p_medicine_id, p_quantity, p_usage_desc
    );

    -- 步骤3：扣减药品库存（核心操作3）
    UPDATE Medicine
    SET stock = stock - p_quantity
    WHERE medicine_id = p_medicine_id;

    -- 提交事务
    COMMIT;
    SET p_result = CONCAT('处方开立成功！处方ID：', v_prescription_id);

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_patient_pay_with_visit_status
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_patient_pay_with_visit_status`;
delimiter ;;
CREATE PROCEDURE `proc_patient_pay_with_visit_status`(IN p_visit_id INT,          -- 就诊ID
    IN p_prescription_id INT,   -- 处方ID（无处方传NULL）
    IN p_total_amount DECIMAL(10,2), -- 总费用
    IN p_insurance_amount DECIMAL(10,2), -- 医保报销金额
    IN p_self_pay_amount DECIMAL(10,2), -- 个人自付金额
    IN p_payment_method ENUM('现金', '微信', '支付宝', '医保'), -- 支付方式
    IN p_payer_name VARCHAR(50), -- 付款人姓名
    OUT p_result VARCHAR(100))
BEGIN
    -- 声明异常处理：错误则回滚
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = '缴费失败：系统异常，数据已回滚';
    END;

    -- 启动事务
    START TRANSACTION;

    -- 步骤1：创建缴费记录（核心操作1）
    INSERT INTO Payment (
        visit_id, prescription_id, total_amount, insurance_amount, self_pay_amount,
        payment_method, payment_time, payer_name
    )
    VALUES (
        p_visit_id, p_prescription_id, p_total_amount, p_insurance_amount, p_self_pay_amount,
        p_payment_method, NOW(), p_payer_name
    );

    -- 步骤2：更新就诊记录状态为“已缴费”（核心操作2）
    UPDATE VisitRecord
    SET visit_status = '已缴费'
    WHERE visit_id = p_visit_id;

    -- 提交事务
    COMMIT;
    SET p_result = CONCAT('缴费成功！缴费ID：', LAST_INSERT_ID());
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_patient_register_with_visit
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_patient_register_with_visit`;
delimiter ;;
CREATE PROCEDURE `proc_patient_register_with_visit`(IN p_patient_id INT,        -- 患者ID
    IN p_doctor_id INT,         -- 接诊医生ID
    IN p_room_id INT,           -- 诊室ID
    IN p_appointment_id INT,    -- 预约ID（无预约传NULL）
    OUT p_result VARCHAR(100))
BEGIN
    -- 声明异常处理：发生错误则回滚事务
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK; -- 回滚所有操作
        SET p_result = '挂号失败：系统异常，数据已回滚';
    END;

    -- 启动事务
    START TRANSACTION;

    -- 步骤1：创建就诊记录（核心操作1）
    INSERT INTO VisitRecord (
        patient_id, doctor_id, room_id, appointment_id, visit_time, symptoms, diagnosis, visit_status
    )
    VALUES (
        p_patient_id, p_doctor_id, p_room_id, p_appointment_id, NOW(), '', '', '就诊中'
    );

    -- 步骤2：若有预约，更新预约状态为“已完成”（核心操作2）
    IF p_appointment_id IS NOT NULL THEN
        UPDATE Appointment
        SET appointment_status = '已完成'
        WHERE appointment_id = p_appointment_id;
    END IF;

    -- 提交事务（所有步骤执行成功才提交）
    COMMIT;
    SET p_result = CONCAT('挂号成功！就诊ID：', LAST_INSERT_ID());
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_pharmacy_dispense_with_prescription
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_pharmacy_dispense_with_prescription`;
delimiter ;;
CREATE PROCEDURE `proc_pharmacy_dispense_with_prescription`(IN p_prescription_id INT,   -- 处方ID
    OUT p_result VARCHAR(100))
dispense_label: BEGIN -- 1. 添加存储过程标签，用于LEAVE退出
    DECLARE v_prescription_status VARCHAR(20); -- 存储处方当前状态
    -- 声明异常处理：错误则回滚
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = '发药失败：系统异常，数据已回滚';
    END;
    -- 步骤0：先查询处方状态，判断是否为“未取药”
    SELECT prescription_status INTO v_prescription_status
    FROM Prescription
    WHERE prescription_id = p_prescription_id;
    IF v_prescription_status != '未取药' THEN
        SET p_result = CONCAT('发药失败：处方状态异常（当前状态：', v_prescription_status, '，仅“未取药”处方可发药）');
        LEAVE dispense_label; -- 2. 用LEAVE替代RETURN，退出存储过程（兼容低版本）
    END IF;
    -- 启动事务
    START TRANSACTION;
    -- 步骤1：更新处方状态为“已取药”（核心操作1）
    UPDATE Prescription
    SET prescription_status = '已取药'
    WHERE prescription_id = p_prescription_id;
    COMMIT;
    SET p_result = CONCAT('发药成功！处方ID：', p_prescription_id, ' 状态已更新为“已取药”');
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_query_lack_medicine
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_query_lack_medicine`;
delimiter ;;
CREATE PROCEDURE `proc_query_lack_medicine`(IN p_min_stock INT)
BEGIN
    -- 查询低库存药品（对应英文视图v_medicine_stock，单条SELECT）
    SELECT 
        medicine_id AS 药品ID,
        medicine_name AS 药品名称,
        medicine_spec AS 药品规格,
        medicine_unit AS 药品单位,
        medicine_unit_price AS 药品单价,
        stock_quantity AS 当前库存,
        manufacturer AS 生产厂家,
        expiry_date AS 有效期,
        is_available AS 是否可用
    FROM v_medicine_stock
    WHERE stock_quantity < p_min_stock
    ORDER BY stock_quantity ASC; -- 按库存从少到多排序，优先补货
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_query_patient_full_info
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_query_patient_full_info`;
delimiter ;;
CREATE PROCEDURE `proc_query_patient_full_info`(IN p_patient_id INT)
BEGIN
    -- 1. 创建临时表（仅当前会话有效，自动销毁，不残留数据）
    DROP TEMPORARY TABLE IF EXISTS temp_patient_detail;
    CREATE TEMPORARY TABLE temp_patient_detail (
        info_type VARCHAR(50) COMMENT '信息类型',
        info_content TEXT COMMENT '信息内容'
    ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;

    -- 2. 插入患者基础信息（对应英文视图v_patient_info）
    INSERT INTO temp_patient_detail (info_type, info_content)
    SELECT 
        'patient_basic',
        CONCAT(
            '患者ID：', patient_id, '，姓名：', patient_name, '，性别：', gender, '，年龄：', age,
            '，联系电话：', phone_number, '，身份证号：', id_card_number, '，居住地址：', residential_address,
            '，建档时间：', DATE_FORMAT(create_datetime, '%Y-%m-%d %H:%i:%s')
        )
    FROM v_patient_info 
    WHERE patient_id = p_patient_id;

    -- 3. 插入患者预约信息（对应英文视图v_appointment_info）
    INSERT INTO temp_patient_detail (info_type, info_content)
    SELECT 
        'appointment_info',
        CONCAT(
            '预约ID：', appointment_id, '，科室名称：', department_name, '，医生姓名：', doctor_name,
            '，预约时间：', DATE_FORMAT(expected_datetime, '%Y-%m-%d %H:%i:%s'), '，预约状态：', appointment_status,
            '，建档时间：', DATE_FORMAT(create_datetime, '%Y-%m-%d %H:%i:%s'), '，取消时间：', IF(cancel_datetime IS NULL, '无', DATE_FORMAT(cancel_datetime, '%Y-%m-%d %H:%i:%s'))
        )
    FROM v_appointment_info 
    WHERE patient_id = p_patient_id;

    -- 4. 插入患者就诊记录（对应英文视图v_visit_record_info）
    INSERT INTO temp_patient_detail (info_type, info_content)
    SELECT 
        'visit_record',
        CONCAT(
            '就诊ID：', visit_id, '，医生姓名：', doctor_name, '，诊室编号：', clinic_room_number,
            '，预约ID：', IF(appointment_id IS NULL, '无', appointment_id), '，就诊时间：', DATE_FORMAT(visit_datetime, '%Y-%m-%d %H:%i:%s'),
            '，患者症状：', patient_symptoms, '，诊断结果：', diagnosis_result, '，就诊状态：', visit_status
        )
    FROM v_visit_record_info 
    WHERE patient_id = p_patient_id;

    -- 5. 插入患者处方药品明细（对应英文视图v_prescription_medicine_info）
    INSERT INTO temp_patient_detail (info_type, info_content)
    SELECT 
        'prescription_medicine',
        CONCAT(
            '处方ID：', prescription_id, '，药品名称：', medicine_name, '，药品规格：', medicine_spec,
            '，药品单位：', medicine_unit, '，单价：', medicine_unit_price, '，数量：', medicine_quantity,
            '，药品小计：', medicine_subtotal, '，用法用量：', usage_instructions, '，开方时间：', DATE_FORMAT(prescribe_datetime, '%Y-%m-%d %H:%i:%s'),
            '，处方状态：', prescription_status
        )
    FROM v_prescription_medicine_info pm
    LEFT JOIN v_visit_record_info vr ON pm.visit_id = vr.visit_id
    WHERE vr.patient_id = p_patient_id;

    -- 6. 插入患者缴费记录（对应英文视图v_payment_info）
    INSERT INTO temp_patient_detail (info_type, info_content)
    SELECT 
        'payment_info',
        CONCAT(
            '缴费ID：', payment_id, '，处方ID：', IF(prescription_id IS NULL, '无', prescription_id), '，总费用：', total_amount,
            '，医保报销：', insurance_reimbursement, '，个人自付：', personal_self_pay, '，支付方式：', payment_method,
            '，缴费时间：', DATE_FORMAT(payment_datetime, '%Y-%m-%d %H:%i:%s'), '，付款人：', payer_name
        )
    FROM v_payment_info 
    WHERE patient_id = p_patient_id;

    -- 7. 统一查询临时表，返回所有患者信息（单条SELECT，无语法错误）
    SELECT * FROM temp_patient_detail;

    -- 8. 手动删除临时表（可选，会话结束后自动销毁）
    DROP TEMPORARY TABLE IF EXISTS temp_patient_detail;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proc_query_visit_statistics
-- ----------------------------
DROP PROCEDURE IF EXISTS `proc_query_visit_statistics`;
delimiter ;;
CREATE PROCEDURE `proc_query_visit_statistics`(IN p_start_time DATETIME,
    IN p_end_time DATETIME,
    IN p_group_type VARCHAR(20))
BEGIN
    -- 单分支单SELECT，规避低版本语法限制
    IF p_group_type = 'dept' THEN
        -- 按科室分组统计
        SELECT 
            de.department_name AS 科室名称,
            COUNT(vr.visit_id) AS 就诊总次数,
            COUNT(DISTINCT vr.patient_id) AS 就诊患者数
        FROM v_visit_record_info vr
        LEFT JOIN v_doctor_info de ON vr.doctor_id = de.doctor_id
        WHERE vr.visit_datetime BETWEEN p_start_time AND p_end_time
        GROUP BY de.department_name
        ORDER BY 就诊总次数 DESC;
    ELSEIF p_group_type = 'doctor' THEN
        -- 按医生分组统计
        SELECT 
            de.doctor_name AS 医生姓名,
            de.department_name AS 科室名称,
            COUNT(vr.visit_id) AS 就诊总次数,
            COUNT(DISTINCT vr.patient_id) AS 就诊患者数
        FROM v_visit_record_info vr
        LEFT JOIN v_doctor_info de ON vr.doctor_id = de.doctor_id
        WHERE vr.visit_datetime BETWEEN p_start_time AND p_end_time
        GROUP BY de.doctor_id, de.doctor_name, de.department_name
        ORDER BY 就诊总次数 DESC;
    ELSEIF p_group_type = 'all' THEN
        -- 不分组，整体统计
        SELECT 
            COUNT(vr.visit_id) AS 就诊总次数,
            COUNT(DISTINCT vr.patient_id) AS 就诊患者数,
            COUNT(DISTINCT vr.doctor_id) AS 接诊医生数
        FROM v_visit_record_info vr
        WHERE vr.visit_datetime BETWEEN p_start_time AND p_end_time;
    ELSE
        -- 无效分组类型，返回提示
        SELECT 'Invalid group type! Support: dept/doctor/all' AS 错误提示;
    END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table patient
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_patient_before_delete`;
delimiter ;;
CREATE TRIGGER `trg_patient_before_delete` BEFORE DELETE ON `patient` FOR EACH ROW BEGIN
    -- 检查该患者是否存在就诊记录
    DECLARE visit_count INT DEFAULT 0;
    SELECT COUNT(*) INTO visit_count
    FROM VisitRecord
    WHERE patient_id = OLD.patient_id;
    
    -- 若存在就诊记录，抛出异常，阻止删除
    IF visit_count > 0 THEN
        SIGNAL SQLSTATE '45000' -- 自定义异常状态码
        SET MESSAGE_TEXT = '该患者已有就诊记录，禁止删除！';
    END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table payment
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_payment_after_insert`;
delimiter ;;
CREATE TRIGGER `trg_payment_after_insert` AFTER INSERT ON `payment` FOR EACH ROW BEGIN
    -- 更新对应就诊记录的状态
    UPDATE VisitRecord
    SET visit_status = '已缴费'
    WHERE visit_id = NEW.visit_id
      AND visit_status <> '已离院'; -- 仅当就诊状态未为“已离院”时更新
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table prescription
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_prescription_before_update`;
delimiter ;;
CREATE TRIGGER `trg_prescription_before_update` BEFORE UPDATE ON `prescription` FOR EACH ROW BEGIN
    -- 声明变量（提前处理字符串，避免嵌套函数）
    DECLARE lack_medicine VARCHAR(200) DEFAULT '';
    DECLARE done INT DEFAULT 0;
    DECLARE med_name VARCHAR(100);
    DECLARE med_quantity INT;
    DECLARE med_stock INT;
    DECLARE error_msg VARCHAR(250) DEFAULT ''; -- 新增：单独存储错误信息
    
    -- 声明游标
    DECLARE cur_medicine CURSOR FOR
        SELECT m.medicine_name, pm.quantity, m.stock
        FROM PrescriptionMedicine pm
        LEFT JOIN Medicine m ON pm.medicine_id = m.medicine_id
        WHERE pm.prescription_id = NEW.prescription_id;
    
    -- 游标处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    -- 业务逻辑
    IF OLD.prescription_status <> '已取药' AND NEW.prescription_status = '已取药' THEN
        OPEN cur_medicine;
        medicine_loop: LOOP
            FETCH cur_medicine INTO med_name, med_quantity, med_stock;
            IF done = 1 THEN LEAVE medicine_loop; END IF;
            -- 拼接库存不足信息
            IF med_stock IS NULL OR med_stock < med_quantity THEN
                SET lack_medicine = CONCAT(lack_medicine, med_name, '（需', med_quantity, '，库存', IFNULL(med_stock, 0), '）；');
            END IF;
        END LOOP medicine_loop;
        CLOSE cur_medicine;
        
        -- 提前处理错误信息（避免嵌套函数）
        IF lack_medicine <> '' THEN
            SET error_msg = CONCAT('药品库存不足，无法标记为已取药：', LEFT(lack_medicine, 100));
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = error_msg;
        END IF;
    END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table prescriptionmedicine
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_prescription_medicine_after_insert`;
delimiter ;;
CREATE TRIGGER `trg_prescription_medicine_after_insert` AFTER INSERT ON `prescriptionmedicine` FOR EACH ROW -- 行级触发器，每插入一条记录执行一次
BEGIN
    -- 更新药品库存：原库存 - 新增处方药品数量
    UPDATE Medicine
    SET stock = stock - NEW.quantity
    WHERE medicine_id = NEW.medicine_id
      AND is_available = TRUE; -- 仅扣减可用药品库存
END
;;
delimiter ;

SET FOREIGN_KEY_CHECKS = 1;
